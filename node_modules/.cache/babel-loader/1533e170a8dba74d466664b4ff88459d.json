{"ast":null,"code":"import { Map } from 'immutable';\nimport React, { useRef, useEffect, Component, useLayoutEffect } from 'react';\nimport clsx from 'clsx';\nimport PropTypes from 'prop-types';\nimport { Modifier, EditorState, genKey } from 'draft-js';\nimport escapeRegExp from 'lodash-es/escapeRegExp';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction MentionLink(_ref) {\n  var mention = _ref.mention,\n      children = _ref.children,\n      className = _ref.className;\n  return /*#__PURE__*/React.createElement(\"a\", {\n    href: mention.link,\n    className: className,\n    spellCheck: false,\n    \"data-testid\": \"mentionLink\"\n  }, children);\n}\n\nfunction MentionText(_ref2) {\n  var children = _ref2.children,\n      className = _ref2.className;\n  return /*#__PURE__*/React.createElement(\"span\", {\n    className: className,\n    spellCheck: false,\n    \"data-testid\": \"mentionText\"\n  }, children);\n}\n\nfunction Mention(props) {\n  var entityKey = props.entityKey,\n      _props$theme = props.theme,\n      theme = _props$theme === void 0 ? {} : _props$theme,\n      mentionComponent = props.mentionComponent,\n      children = props.children,\n      decoratedText = props.decoratedText,\n      className = props.className,\n      contentState = props.contentState;\n  var combinedClassName = clsx(theme.mention, className);\n  var mention = contentState.getEntity(entityKey).getData().mention;\n  var Component = mentionComponent || (mention.link ? MentionLink : MentionText);\n  return /*#__PURE__*/React.createElement(Component, {\n    entityKey: entityKey,\n    mention: mention,\n    theme: theme,\n    className: combinedClassName,\n    decoratedText: decoratedText\n  }, children);\n}\n\nvar Entry = function Entry(props) {\n  var mouseDown = useRef(false);\n  useEffect(function () {\n    mouseDown.current = false;\n  });\n\n  var onMouseUp = function onMouseUp() {\n    if (mouseDown.current) {\n      props.onMentionSelect(props.mention);\n      mouseDown.current = false;\n    }\n  };\n\n  var onMouseDown = function onMouseDown(event) {\n    // Note: important to avoid a content edit change\n    event.preventDefault();\n    mouseDown.current = true;\n  };\n\n  var onMouseEnter = function onMouseEnter() {\n    props.onMentionFocus(props.index);\n  };\n\n  var _props$theme = props.theme,\n      theme = _props$theme === void 0 ? {} : _props$theme,\n      mention = props.mention,\n      searchValue = props.searchValue,\n      isFocused = props.isFocused,\n      id = props.id;\n  var className = isFocused ? theme.mentionSuggestionsEntryFocused : theme.mentionSuggestionsEntry;\n  var EntryComponent = props.entryComponent;\n  return /*#__PURE__*/React.createElement(EntryComponent, {\n    className: className,\n    onMouseDown: onMouseDown,\n    onMouseUp: onMouseUp,\n    onMouseEnter: onMouseEnter,\n    role: \"option\",\n    id: id,\n    \"aria-selected\": isFocused ? 'true' : undefined,\n    theme: theme,\n    mention: mention,\n    isFocused: isFocused,\n    searchValue: searchValue\n  });\n};\n\nEntry.propTypes = {\n  entryComponent: PropTypes.any.isRequired,\n  searchValue: PropTypes.string,\n  // eslint-disable-next-line react/no-unused-prop-types\n  onMentionSelect: PropTypes.func\n};\n/**\n * Return tail end of the string matching trigger upto the position.\n */\n\nfunction getSearchTextAt(blockText, position, triggers) {\n  var str = blockText.substr(0, position);\n\n  var _triggers$map$reduce = triggers.map(function (trigger, triggerIndex) {\n    return {\n      begin: trigger.length === 0 ? 0 : str.lastIndexOf(trigger),\n      index: triggerIndex\n    };\n  }).reduce(function (left, right) {\n    return left.begin >= right.begin ? left : right;\n  }),\n      begin = _triggers$map$reduce.begin,\n      index = _triggers$map$reduce.index;\n\n  var matchingString = triggers[index].length === 0 ? str : str.slice(begin + triggers[index].length);\n  var end = str.length;\n  return {\n    begin: begin,\n    end: end,\n    matchingString: matchingString\n  };\n}\n\nvar getSearchText = function (editorState, selection, triggers) {\n  var anchorKey = selection.getAnchorKey();\n  var anchorOffset = selection.getAnchorOffset();\n  var currentContent = editorState.getCurrentContent();\n  var currentBlock = currentContent.getBlockForKey(anchorKey);\n  var blockText = currentBlock.getText();\n  return getSearchTextAt(blockText, anchorOffset, triggers);\n};\n\nfunction getTypeByTrigger(trigger) {\n  return trigger === '@' ? 'mention' : trigger + \"mention\";\n}\n\nfunction addMention(editorState, mention, mentionPrefix, mentionTrigger, entityMutability) {\n  var contentStateWithEntity = editorState.getCurrentContent().createEntity(getTypeByTrigger(mentionTrigger), entityMutability, {\n    mention: mention\n  });\n  var entityKey = contentStateWithEntity.getLastCreatedEntityKey();\n  var currentSelectionState = editorState.getSelection();\n\n  var _getSearchText = getSearchText(editorState, currentSelectionState, [mentionTrigger]),\n      begin = _getSearchText.begin,\n      end = _getSearchText.end; // get selection of the @mention search text\n\n\n  var mentionTextSelection = currentSelectionState.merge({\n    anchorOffset: begin,\n    focusOffset: end\n  });\n  var mentionReplacedContent = Modifier.replaceText(editorState.getCurrentContent(), mentionTextSelection, \"\" + mentionPrefix + mention.name, undefined, // no inline style needed\n  entityKey); // If the mention is inserted at the end, a space is appended right after for\n  // a smooth writing experience.\n\n  var blockKey = mentionTextSelection.getAnchorKey();\n  var blockSize = editorState.getCurrentContent().getBlockForKey(blockKey).getLength();\n\n  if (blockSize === end) {\n    mentionReplacedContent = Modifier.insertText(mentionReplacedContent, mentionReplacedContent.getSelectionAfter(), ' ');\n  }\n\n  var newEditorState = EditorState.push(editorState, mentionReplacedContent, 'insert-fragment');\n  return EditorState.forceSelection(newEditorState, mentionReplacedContent.getSelectionAfter());\n}\n\nvar decodeOffsetKey = function decodeOffsetKey(offsetKey) {\n  var _offsetKey$split = offsetKey.split('-'),\n      blockKey = _offsetKey$split[0],\n      decoratorKey = _offsetKey$split[1],\n      leafKey = _offsetKey$split[2];\n\n  return {\n    blockKey: blockKey,\n    decoratorKey: parseInt(decoratorKey, 10),\n    leafKey: parseInt(leafKey, 10)\n  };\n};\n\nfunction Avatar(_ref) {\n  var mention = _ref.mention,\n      _ref$theme = _ref.theme,\n      theme = _ref$theme === void 0 ? {} : _ref$theme;\n\n  if (mention.avatar) {\n    return /*#__PURE__*/React.createElement(\"img\", {\n      src: mention.avatar,\n      className: theme.mentionSuggestionsEntryAvatar,\n      role: \"presentation\"\n    });\n  }\n\n  return null;\n}\n\nfunction DefaultEntryComponent(props) {\n  var mention = props.mention,\n      theme = props.theme;\n  props.isFocused;\n  props.searchValue;\n\n  var parentProps = _objectWithoutPropertiesLoose(props, [\"mention\", \"theme\", \"isFocused\", \"searchValue\"]);\n\n  return /*#__PURE__*/React.createElement(\"div\", parentProps, /*#__PURE__*/React.createElement(Avatar, {\n    mention: mention,\n    theme: theme\n  }), /*#__PURE__*/React.createElement(\"span\", {\n    className: theme == null ? void 0 : theme.mentionSuggestionsEntryText\n  }, mention.name));\n}\n\nvar MentionSuggestions = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(MentionSuggestions, _Component);\n\n  function MentionSuggestions(props) {\n    var _this;\n\n    _this = _Component.call(this, props) || this;\n    _this.state = {\n      focusedOptionIndex: 0\n    };\n    _this.key = genKey();\n    _this.popover = void 0;\n    _this.activeOffsetKey = void 0;\n    _this.lastSearchValue = void 0;\n    _this.lastActiveTrigger = '';\n    _this.lastSelectionIsInsideWord = void 0;\n\n    _this.onEditorStateChange = function (editorState) {\n      var searches = _this.props.store.getAllSearches(); // if no search portal is active there is no need to show the popover\n\n\n      if (searches.size === 0) {\n        return editorState;\n      }\n\n      var removeList = function removeList() {\n        _this.props.store.resetEscapedSearch();\n\n        _this.closeDropdown();\n\n        return editorState;\n      }; // get the current selection\n\n\n      var selection = editorState.getSelection();\n      var anchorKey = selection.getAnchorKey();\n      var anchorOffset = selection.getAnchorOffset(); // the list should not be visible if a range is selected or the editor has no focus\n\n      if (!selection.isCollapsed() || !selection.getHasFocus()) return removeList(); // identify the start & end positon of each search-text\n\n      var offsetDetails = searches.map(function (offsetKey) {\n        return decodeOffsetKey(offsetKey);\n      }); // a leave can be empty when it is removed due event.g. using backspace\n      // do not check leaves, use full decorated portal text\n\n      var leaves = offsetDetails.filter(function (offsetDetail) {\n        return offsetDetail.blockKey === anchorKey;\n      }).map(function (offsetDetail) {\n        return editorState.getBlockTree(offsetDetail.blockKey).getIn([offsetDetail.decoratorKey]);\n      }); // if all leaves are undefined the popover should be removed\n\n      if (leaves.every(function (leave) {\n        return leave === undefined;\n      })) {\n        return removeList();\n      } // Checks that the cursor is after the @ character but still somewhere in\n      // the word (search term). Setting it to allow the cursor to be left of\n      // the @ causes troubles due selection confusion.\n\n\n      var blockText = editorState.getCurrentContent().getBlockForKey(anchorKey).getText();\n      var triggerForSelectionInsideWord = leaves.filter(function (leave) {\n        return leave !== undefined;\n      }).map(function (_ref) {\n        var start = _ref.start,\n            end = _ref.end;\n        return _this.props.mentionTriggers.map(function (trigger) {\n          return (// @ is the first character\n            start === 0 && anchorOffset >= start + trigger.length && //should not trigger if the cursor is before the trigger\n            blockText.substr(0, trigger.length) === trigger && anchorOffset <= end || // @ is in the text or at the end, multi triggers\n            _this.props.mentionTriggers.length > 1 && anchorOffset >= start + trigger.length && (blockText.substr(start + 1, trigger.length) === trigger || blockText.substr(start, trigger.length) === trigger) && anchorOffset <= end || // @ is in the text or at the end, single trigger\n            _this.props.mentionTriggers.length === 1 && anchorOffset >= start + trigger.length && anchorOffset <= end ? trigger : undefined\n          );\n        }).filter(function (trigger) {\n          return trigger !== undefined;\n        })[0];\n      }).filter(function (trigger) {\n        return trigger !== undefined;\n      });\n      if (triggerForSelectionInsideWord.isEmpty()) return removeList();\n\n      var _triggerForSelectionI = triggerForSelectionInsideWord.entrySeq().first(),\n          activeOffsetKey = _triggerForSelectionI[0],\n          activeTrigger = _triggerForSelectionI[1];\n\n      var lastActiveOffsetKey = _this.activeOffsetKey;\n      _this.activeOffsetKey = activeOffsetKey;\n\n      _this.onSearchChange(editorState, selection, _this.activeOffsetKey, lastActiveOffsetKey, activeTrigger); // make sure the escaped search is reseted in the cursor since the user\n      // already switched to another mention search\n\n\n      if (!_this.props.store.isEscaped(_this.activeOffsetKey || '')) {\n        _this.props.store.resetEscapedSearch();\n      } // If none of the above triggered to close the window, it's safe to assume\n      // the dropdown should be open. This is useful when a user focuses on another\n      // input field and then comes back: the dropdown will show again.\n\n\n      if (!_this.props.open && !_this.props.store.isEscaped(_this.activeOffsetKey || '')) {\n        _this.openDropdown();\n      } // makes sure the focused index is reseted every time a new selection opens\n      // or the selection was moved to another mention search\n\n\n      if (lastActiveOffsetKey !== _this.activeOffsetKey) {\n        _this.setState({\n          focusedOptionIndex: 0\n        });\n      }\n\n      return editorState;\n    };\n\n    _this.onSearchChange = function (editorState, selection, activeOffsetKey, lastActiveOffsetKey, trigger) {\n      var _getSearchText = getSearchText(editorState, selection, [trigger]),\n          searchValue = _getSearchText.matchingString;\n\n      if (_this.lastActiveTrigger !== trigger || _this.lastSearchValue !== searchValue || activeOffsetKey !== lastActiveOffsetKey) {\n        _this.lastActiveTrigger = trigger;\n        _this.lastSearchValue = searchValue;\n\n        _this.props.onSearchChange({\n          trigger: trigger,\n          value: searchValue\n        });\n      }\n    };\n\n    _this.onDownArrow = function (keyboardEvent) {\n      keyboardEvent.preventDefault();\n      var newIndex = _this.state.focusedOptionIndex + 1;\n\n      _this.onMentionFocus(newIndex >= _this.props.suggestions.length ? 0 : newIndex);\n    };\n\n    _this.onTab = function (keyboardEvent) {\n      keyboardEvent.preventDefault();\n\n      _this.commitSelection();\n    };\n\n    _this.onUpArrow = function (keyboardEvent) {\n      keyboardEvent.preventDefault();\n\n      if (_this.props.suggestions.length > 0) {\n        var newIndex = _this.state.focusedOptionIndex - 1;\n\n        _this.onMentionFocus(newIndex < 0 ? _this.props.suggestions.length - 1 : newIndex);\n      }\n    };\n\n    _this.onEscape = function (keyboardEvent) {\n      keyboardEvent.preventDefault();\n\n      _this.props.store.escapeSearch(_this.activeOffsetKey || '');\n\n      _this.closeDropdown(); // to force a re-render of the outer component to change the aria props\n\n\n      _this.props.store.setEditorState(_this.props.store.getEditorState());\n    };\n\n    _this.onMentionSelect = function (mention) {\n      // Note: This can happen in case a user typed @xxx (invalid mention) and\n      // then hit Enter. Then the mention will be undefined.\n      if (!mention) {\n        return;\n      }\n\n      if (_this.props.onAddMention) {\n        _this.props.onAddMention(mention);\n      }\n\n      _this.closeDropdown();\n\n      var newEditorState = addMention(_this.props.store.getEditorState(), mention, _this.props.mentionPrefix, _this.lastActiveTrigger || '', _this.props.entityMutability);\n\n      _this.props.store.setEditorState(newEditorState);\n    };\n\n    _this.onMentionFocus = function (index) {\n      var descendant = \"mention-option-\" + _this.key + \"-\" + index;\n      _this.props.ariaProps.ariaActiveDescendantID = descendant;\n\n      _this.setState({\n        focusedOptionIndex: index\n      }); // to force a re-render of the outer component to change the aria props\n\n\n      _this.props.store.setEditorState(_this.props.store.getEditorState());\n    };\n\n    _this.commitSelection = function () {\n      if (!_this.props.store.getIsOpened()) {\n        return 'not-handled';\n      }\n\n      _this.onMentionSelect(_this.props.suggestions[_this.state.focusedOptionIndex]);\n\n      return 'handled';\n    };\n\n    _this.openDropdown = function () {\n      // This is a really nasty way of attaching & releasing the key related functions.\n      // It assumes that the keyFunctions object will not loose its reference and\n      // by this we can replace inner parameters spread over different modules.\n      // This better be some registering & unregistering logic. PRs are welcome :)\n      _this.props.callbacks.handleReturn = _this.commitSelection;\n\n      _this.props.callbacks.keyBindingFn = function (keyboardEvent) {\n        // arrow down\n        if (keyboardEvent.keyCode === 40) {\n          _this.onDownArrow(keyboardEvent);\n        } // arrow up\n\n\n        if (keyboardEvent.keyCode === 38) {\n          _this.onUpArrow(keyboardEvent);\n        } // escape\n\n\n        if (keyboardEvent.keyCode === 27) {\n          _this.onEscape(keyboardEvent);\n        } // tab\n\n\n        if (keyboardEvent.keyCode === 9) {\n          _this.onTab(keyboardEvent);\n        }\n\n        return undefined;\n      };\n\n      var descendant = \"mention-option-\" + _this.key + \"-\" + _this.state.focusedOptionIndex;\n      _this.props.ariaProps.ariaActiveDescendantID = descendant;\n      _this.props.ariaProps.ariaOwneeID = \"mentions-list-\" + _this.key;\n      _this.props.ariaProps.ariaHasPopup = 'true';\n      _this.props.ariaProps.ariaExpanded = true;\n\n      _this.props.onOpenChange(true);\n    };\n\n    _this.closeDropdown = function () {\n      // make sure none of these callbacks are triggered\n      _this.props.callbacks.handleReturn = undefined;\n      _this.props.callbacks.keyBindingFn = undefined;\n      _this.props.ariaProps.ariaHasPopup = 'false';\n      _this.props.ariaProps.ariaExpanded = false;\n      _this.props.ariaProps.ariaActiveDescendantID = undefined;\n      _this.props.ariaProps.ariaOwneeID = undefined;\n\n      _this.props.onOpenChange(false);\n    };\n\n    _this.props.callbacks.onChange = _this.onEditorStateChange;\n    return _this;\n  }\n\n  var _proto = MentionSuggestions.prototype;\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    if (this.popover) {\n      // In case the list shrinks there should be still an option focused.\n      // Note: this might run multiple times and deduct 1 until the condition is\n      // not fullfilled anymore.\n      var size = this.props.suggestions.length;\n\n      if (size > 0 && this.state.focusedOptionIndex >= size) {\n        this.setState({\n          focusedOptionIndex: size - 1\n        });\n      } // Note: this is a simple protection for the error when componentDidUpdate\n      // try to get new getPortalClientRect, but the key already was deleted by\n      // previous action. (right now, it only can happened when set the mention\n      // trigger to be multi-characters which not supported anyway!)\n\n\n      if (!this.props.store.getAllSearches().has(this.activeOffsetKey)) {\n        return;\n      }\n\n      var decoratorRect = this.props.store.getPortalClientRect(this.activeOffsetKey);\n      var newStyles = this.props.positionSuggestions({\n        decoratorRect: decoratorRect,\n        props: this.props,\n        popover: this.popover\n      });\n\n      for (var _i = 0, _Object$entries = Object.entries(newStyles); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _Object$entries[_i],\n            key = _Object$entries$_i[0],\n            value = _Object$entries$_i[1]; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n        this.popover.style[key] = value;\n      }\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.props.callbacks.onChange = undefined;\n  };\n\n  _proto.render = function render() {\n    var _this2 = this;\n\n    if (!this.props.open) {\n      return null;\n    }\n\n    var _this$props = this.props,\n        entryComponent = _this$props.entryComponent,\n        _this$props$popoverCo = _this$props.popoverComponent,\n        popoverComponent = _this$props$popoverCo === void 0 ? /*#__PURE__*/React.createElement(\"div\", null) : _this$props$popoverCo;\n    _this$props.onOpenChange;\n    _this$props.onAddMention;\n    _this$props.onSearchChange;\n    _this$props.suggestions;\n    _this$props.ariaProps;\n    _this$props.callbacks;\n    var _this$props$theme = _this$props.theme,\n        theme = _this$props$theme === void 0 ? {} : _this$props$theme;\n    _this$props.store;\n    _this$props.entityMutability;\n    _this$props.positionSuggestions;\n    _this$props.mentionTriggers;\n    _this$props.mentionPrefix;\n\n    var elementProps = _objectWithoutPropertiesLoose(_this$props, [\"entryComponent\", \"popoverComponent\", \"onOpenChange\", \"onAddMention\", \"onSearchChange\", \"suggestions\", \"ariaProps\", \"callbacks\", \"theme\", \"store\", \"entityMutability\", \"positionSuggestions\", \"mentionTriggers\", \"mentionPrefix\"]);\n\n    return /*#__PURE__*/React.cloneElement(popoverComponent, _extends({}, elementProps, {\n      className: theme.mentionSuggestions,\n      role: 'listbox',\n      id: \"mentions-list-\" + this.key,\n      ref: function ref(element) {\n        _this2.popover = element;\n      }\n    }), this.props.suggestions.map(function (mention, index) {\n      return /*#__PURE__*/React.createElement(Entry, {\n        key: mention.id != null ? mention.id : mention.name,\n        onMentionSelect: _this2.onMentionSelect,\n        onMentionFocus: _this2.onMentionFocus,\n        isFocused: _this2.state.focusedOptionIndex === index,\n        mention: mention,\n        index: index,\n        id: \"mention-option-\" + _this2.key + \"-\" + index,\n        theme: theme,\n        searchValue: _this2.lastSearchValue,\n        entryComponent: entryComponent || DefaultEntryComponent\n      });\n    }));\n  };\n\n  return MentionSuggestions;\n}(Component);\n\nMentionSuggestions.propTypes = {\n  open: PropTypes.bool.isRequired,\n  onOpenChange: PropTypes.func.isRequired,\n  entityMutability: PropTypes.oneOf(['SEGMENTED', 'IMMUTABLE', 'MUTABLE']),\n  entryComponent: PropTypes.func,\n  onAddMention: PropTypes.func,\n  suggestions: PropTypes.array.isRequired\n};\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\nfunction MentionSuggestionsPortal(props) {\n  var searchPortal = useRef(); // Note: this is a workaround for an obscure issue: https://github.com/draft-js-plugins/draft-js-plugins/pull/667/files\n  // Ideally we can remove this in the future.\n\n  var searchPortalRef = function searchPortalRef(element) {\n    searchPortal.current = element;\n  };\n\n  var updatePortalClientRect = function updatePortalClientRect(currentProps) {\n    currentProps.store.updatePortalClientRect(currentProps.offsetKey, function () {\n      return searchPortal.current.getBoundingClientRect();\n    });\n  }; // When inputting Japanese characters (or any complex alphabet which requires\n  // hitting enter to commit the characters), that action was causing a race\n  // condition when we used UNSAFE_componentWillMount. By using componentDidMount\n  // instead of UNSAFE_componentWillMount, the component will unmount unregister and\n  // then properly mount and register after. Prior to this change,\n  // UNSAFE_componentWillMount would not fire after componentWillUnmount even though it\n  // was still in the DOM, so it wasn't re-registering the offsetkey.\n\n\n  useIsomorphicLayoutEffect(function () {\n    props.store.register(props.offsetKey);\n    props.store.setIsOpened(true);\n    updatePortalClientRect(props); // trigger a re-render so the MentionSuggestions becomes active\n\n    props.store.setEditorState(props.store.getEditorState());\n    return function () {\n      props.store.unregister(props.offsetKey);\n      props.store.setIsOpened(false);\n    };\n  }, []);\n  useEffect(function () {\n    updatePortalClientRect(props);\n  });\n  return /*#__PURE__*/React.createElement(\"span\", {\n    ref: searchPortalRef\n  }, props.children);\n}\n\nvar getRelativeParent = function getRelativeParent(element) {\n  if (!element) {\n    return null;\n  }\n\n  var position = window.getComputedStyle(element).getPropertyValue('position');\n\n  if (position !== 'static') {\n    return element;\n  }\n\n  return getRelativeParent(element.parentElement);\n};\n\nfunction positionSuggestions(_ref) {\n  var decoratorRect = _ref.decoratorRect,\n      popover = _ref.popover,\n      props = _ref.props;\n  var relativeParent = getRelativeParent(popover.parentElement);\n  var relativeRect;\n\n  if (relativeParent) {\n    var relativeParentRect = relativeParent.getBoundingClientRect();\n    relativeRect = {\n      scrollLeft: relativeParent.scrollLeft,\n      scrollTop: relativeParent.scrollTop,\n      left: decoratorRect.left - relativeParentRect.left,\n      top: decoratorRect.bottom - relativeParentRect.top\n    };\n  } else {\n    relativeRect = {\n      scrollTop: window.pageYOffset || document.documentElement.scrollTop,\n      scrollLeft: window.pageXOffset || document.documentElement.scrollLeft,\n      top: decoratorRect.bottom,\n      left: decoratorRect.left\n    };\n  }\n\n  var left = relativeRect.left + relativeRect.scrollLeft;\n  var top = relativeRect.top + relativeRect.scrollTop;\n  var transform;\n  var transition;\n\n  if (props.open) {\n    if (props.suggestions.length > 0) {\n      transform = 'scale(1)';\n      transition = 'all 0.25s cubic-bezier(.3,1.2,.2,1)';\n    } else {\n      transform = 'scale(0)';\n      transition = 'all 0.35s cubic-bezier(.3,1,.2,1)';\n    }\n  }\n\n  return {\n    left: left + \"px\",\n    top: top + \"px\",\n    transform: transform,\n    transformOrigin: '1em 0%',\n    transition: transition\n  };\n}\n\nvar defaultRegExp = '[' + '\\\\w-' + // Latin-1 Supplement (letters only) - https://en.wikipedia.org/wiki/List_of_Unicode_characters#Latin-1_Supplement\n\"\\xC0-\\xD6\" + \"\\xD8-\\xF6\" + \"\\xF8-\\xFF\" + // Latin Extended-A (without deprecated character) - https://en.wikipedia.org/wiki/List_of_Unicode_characters#Latin_Extended-A\n\"\\u0100-\\u0148\" + \"\\u014A-\\u017F\" + // Cyrillic symbols: \\u0410-\\u044F - https://en.wikipedia.org/wiki/Cyrillic_script_in_Unicode\n\"\\u0410-\\u044F\" + // hiragana (japanese): \\u3040-\\u309F - https://gist.github.com/ryanmcgrath/982242#file-japaneseregex-js\n\"\\u3040-\\u309F\" + // katakana (japanese): \\u30A0-\\u30FF - https://gist.github.com/ryanmcgrath/982242#file-japaneseregex-js\n\"\\u30A0-\\u30FF\" + // For an advanced explaination about Hangul see https://github.com/draft-js-plugins/draft-js-plugins/pull/480#issuecomment-254055437\n// Hangul Jamo (korean): \\u3130-\\u318F - https://en.wikipedia.org/wiki/Korean_language_and_computers#Hangul_in_Unicode\n// Hangul Syllables (korean): \\uAC00-\\uD7A3 - https://en.wikipedia.org/wiki/Korean_language_and_computers#Hangul_in_Unicode\n\"\\u3130-\\u318F\" + \"\\uAC00-\\uD7A3\" + // common chinese symbols: \\u4e00-\\u9eff - http://stackoverflow.com/a/1366113/837709\n// extended to \\u9fa5 https://github.com/draft-js-plugins/draft-js-plugins/issues/1888\n\"\\u4E00-\\u9FA5\" + // Arabic https://en.wikipedia.org/wiki/Arabic_(Unicode_block)\n\"\\u0600-\\u06FF\" + // Vietnamese http://vietunicode.sourceforge.net/charset/\n\"\\xC0-\\u1EF9\" + ']';\nvar defaultTheme = {\n  mention: \"m6zwb4v\",\n  // CSS class for suggestions component\n  mentionSuggestions: \"mnw6qvm\",\n  // CSS classes for an entry in the suggestions component\n  mentionSuggestionsEntry: \"m1ymsnxd\",\n  mentionSuggestionsEntryFocused: \"m126ak5t\",\n  mentionSuggestionsEntryText: \"mtiwdxc\",\n  mentionSuggestionsEntryAvatar: \"myz2dw1\"\n};\n\nvar findMentionEntities = function findMentionEntities(triggers) {\n  return function (contentBlock, callback, contentState) {\n    contentBlock.findEntityRanges(function (character) {\n      var entityKey = character.getEntity();\n      return entityKey !== null && triggers.some(function (trigger) {\n        return contentState.getEntity(entityKey).getType() === getTypeByTrigger(trigger);\n      });\n    }, callback);\n  };\n};\n\nvar whitespaceRegEx = /\\s/;\n\nfunction checkForWhiteSpaceBeforeTrigger(text, index) {\n  if (index === 0) {\n    return true;\n  }\n\n  return whitespaceRegEx.test(text[index - 1]);\n}\n\nvar findWithRegex = function findWithRegex(regex, contentBlock, supportWhiteSpace, callback) {\n  var contentBlockText = contentBlock.getText(); // exclude entities, when matching\n\n  contentBlock.findEntityRanges(function (character) {\n    return !character.getEntity();\n  }, function (nonEntityStart, nonEntityEnd) {\n    var text = contentBlockText.slice(nonEntityStart, nonEntityEnd);\n    var matchArr;\n    var start;\n    var prevLastIndex = regex.lastIndex; // Go through all matches in the text and return the indices to the callback\n    // Break the loop if lastIndex is not changed\n\n    while ((matchArr = regex.exec(text)) !== null) {\n      // eslint-disable-line\n      if (regex.lastIndex === prevLastIndex) {\n        break;\n      } //console.log(matchArr, text[matchArr.index - 1], text);\n\n\n      prevLastIndex = regex.lastIndex;\n      start = nonEntityStart + matchArr.index;\n\n      var _end = start + matchArr[0].length;\n\n      if (!supportWhiteSpace && whitespaceRegEx.test(text[start])) {\n        //trim the result so that we have no whitespaces\n        start += 1;\n      } //check if whitespace support is active that the char before the trigger is a white space #1844\n\n\n      if (supportWhiteSpace && checkForWhiteSpaceBeforeTrigger(text, matchArr.index) || !supportWhiteSpace) {\n        callback(start, _end);\n      }\n    }\n  });\n};\n\nvar mentionSuggestionsStrategy = function (triggers, supportWhiteSpace, regExp) {\n  //eslint-disable-line\n  var triggerPattern = \"[\" + triggers.map(function (trigger) {\n    return escapeRegExp(trigger);\n  }).join('') + \"]\";\n  var MENTION_REGEX = supportWhiteSpace ? new RegExp(triggerPattern + \"(\" + regExp + \"|\\\\s)*\", 'g') : new RegExp(\"(\\\\s|^)\" + triggerPattern + regExp + \"*\", 'g');\n  return function (contentBlock, callback) {\n    findWithRegex(MENTION_REGEX, contentBlock, supportWhiteSpace, callback);\n  };\n}; // Get the first 5 suggestions that match\n\n\nvar defaultSuggestionsFilter$1 = function defaultSuggestionsFilter(searchValue, suggestions, trigger) {\n  var value = searchValue.toLowerCase();\n  var triggerSuggestions = trigger && !Array.isArray(suggestions) ? suggestions[trigger] : suggestions;\n  var filteredSuggestions = triggerSuggestions.filter(function (suggestion) {\n    return !value || suggestion.name.toLowerCase().indexOf(value) > -1;\n  });\n  var length = filteredSuggestions.length < 5 ? filteredSuggestions.length : 5;\n  return filteredSuggestions.slice(0, length);\n};\n\nvar index = function (config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var callbacks = {\n    keyBindingFn: undefined,\n    handleKeyCommand: undefined,\n    handleReturn: undefined,\n    onChange: undefined\n  };\n  var ariaProps = {\n    ariaHasPopup: 'false',\n    ariaExpanded: false,\n    ariaOwneeID: undefined,\n    ariaActiveDescendantID: undefined\n  };\n  var searches = Map();\n  var escapedSearch;\n  var clientRectFunctions = Map();\n  var isOpened = false;\n  var store = {\n    getEditorState: undefined,\n    setEditorState: undefined,\n    getPortalClientRect: function getPortalClientRect(offsetKey) {\n      return clientRectFunctions.get(offsetKey)();\n    },\n    getAllSearches: function getAllSearches() {\n      return searches;\n    },\n    isEscaped: function isEscaped(offsetKey) {\n      return escapedSearch === offsetKey;\n    },\n    escapeSearch: function escapeSearch(offsetKey) {\n      escapedSearch = offsetKey;\n    },\n    resetEscapedSearch: function resetEscapedSearch() {\n      escapedSearch = undefined;\n    },\n    register: function register(offsetKey) {\n      searches = searches.set(offsetKey, offsetKey);\n    },\n    updatePortalClientRect: function updatePortalClientRect(offsetKey, func) {\n      clientRectFunctions = clientRectFunctions.set(offsetKey, func);\n    },\n    unregister: function unregister(offsetKey) {\n      searches = searches[\"delete\"](offsetKey);\n      clientRectFunctions = clientRectFunctions[\"delete\"](offsetKey);\n    },\n    getIsOpened: function getIsOpened() {\n      return isOpened;\n    },\n    setIsOpened: function setIsOpened(nextIsOpened) {\n      isOpened = nextIsOpened;\n    }\n  }; // Styles are overwritten instead of merged as merging causes a lot of confusion.\n  //\n  // Why? Because when merging a developer needs to know all of the underlying\n  // styles which needs a deep dive into the code. Merging also makes it prone to\n  // errors when upgrading as basically every styling change would become a major\n  // breaking change. 1px of an increased padding can break a whole layout.\n\n  var _config = config,\n      _config$mentionPrefix = _config.mentionPrefix,\n      mentionPrefix = _config$mentionPrefix === void 0 ? '' : _config$mentionPrefix,\n      _config$theme = _config.theme,\n      theme = _config$theme === void 0 ? defaultTheme : _config$theme,\n      _config$positionSugge = _config.positionSuggestions,\n      positionSuggestions$1 = _config$positionSugge === void 0 ? positionSuggestions : _config$positionSugge,\n      mentionComponent = _config.mentionComponent,\n      _config$mentionSugges = _config.mentionSuggestionsComponent,\n      MentionSuggestionsComponent = _config$mentionSugges === void 0 ? MentionSuggestions : _config$mentionSugges,\n      _config$entityMutabil = _config.entityMutability,\n      entityMutability = _config$entityMutabil === void 0 ? 'SEGMENTED' : _config$entityMutabil,\n      _config$mentionTrigge = _config.mentionTrigger,\n      mentionTrigger = _config$mentionTrigge === void 0 ? '@' : _config$mentionTrigge,\n      _config$mentionRegExp = _config.mentionRegExp,\n      mentionRegExp = _config$mentionRegExp === void 0 ? defaultRegExp : _config$mentionRegExp,\n      _config$supportWhites = _config.supportWhitespace,\n      supportWhitespace = _config$supportWhites === void 0 ? false : _config$supportWhites;\n  var mentionTriggers = typeof mentionTrigger === 'string' ? [mentionTrigger] : mentionTrigger;\n  var mentionSearchProps = {\n    ariaProps: ariaProps,\n    callbacks: callbacks,\n    theme: theme,\n    store: store,\n    entityMutability: entityMutability,\n    positionSuggestions: positionSuggestions$1,\n    mentionTriggers: mentionTriggers,\n    mentionPrefix: mentionPrefix\n  };\n\n  var DecoratedMentionSuggestionsComponent = function DecoratedMentionSuggestionsComponent(props) {\n    return /*#__PURE__*/React.createElement(MentionSuggestionsComponent, _extends({}, props, mentionSearchProps));\n  };\n\n  var DecoratedMention = function DecoratedMention(props) {\n    return /*#__PURE__*/React.createElement(Mention, _extends({}, props, {\n      theme: theme,\n      mentionComponent: mentionComponent\n    }));\n  };\n\n  var DecoratedMentionSuggestionsPortal = function DecoratedMentionSuggestionsPortal(props) {\n    return /*#__PURE__*/React.createElement(MentionSuggestionsPortal, _extends({}, props, {\n      store: store\n    }));\n  };\n\n  return {\n    MentionSuggestions: DecoratedMentionSuggestionsComponent,\n    decorators: [{\n      strategy: findMentionEntities(mentionTriggers),\n      component: DecoratedMention\n    }, {\n      strategy: mentionSuggestionsStrategy(mentionTriggers, supportWhitespace, mentionRegExp),\n      component: DecoratedMentionSuggestionsPortal\n    }],\n    getAccessibilityProps: function getAccessibilityProps() {\n      return {\n        role: 'combobox',\n        ariaAutoComplete: 'list',\n        ariaHasPopup: ariaProps.ariaHasPopup,\n        ariaExpanded: ariaProps.ariaExpanded,\n        ariaActiveDescendantID: ariaProps.ariaActiveDescendantID,\n        ariaOwneeID: ariaProps.ariaOwneeID\n      };\n    },\n    initialize: function initialize(_ref) {\n      var getEditorState = _ref.getEditorState,\n          setEditorState = _ref.setEditorState;\n      store.getEditorState = getEditorState;\n      store.setEditorState = setEditorState;\n    },\n    keyBindingFn: function keyBindingFn(keyboardEvent) {\n      return callbacks.keyBindingFn && callbacks.keyBindingFn(keyboardEvent);\n    },\n    handleReturn: function handleReturn(keyboardEvent) {\n      return callbacks.handleReturn && callbacks.handleReturn(keyboardEvent);\n    },\n    onChange: function onChange(editorState) {\n      if (callbacks.onChange) {\n        return callbacks.onChange(editorState);\n      }\n\n      return editorState;\n    }\n  };\n};\n\nvar defaultSuggestionsFilter = defaultSuggestionsFilter$1;\nexport default index;\nexport { MentionSuggestions, addMention, defaultSuggestionsFilter, defaultTheme };","map":null,"metadata":{},"sourceType":"module"}