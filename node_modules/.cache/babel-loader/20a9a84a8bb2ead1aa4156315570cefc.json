{"ast":null,"code":"import React from 'react';\nimport clsx from 'clsx';\nimport linkifyIt from 'linkify-it';\nimport tlds from 'tlds';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nvar linkify = linkifyIt();\nlinkify.tlds(tlds); // The component we render when we encounter a hyperlink in the text\n\nfunction Link(props) {\n  var _props$decoratedText = props.decoratedText,\n      decoratedText = _props$decoratedText === void 0 ? '' : _props$decoratedText,\n      _props$theme = props.theme,\n      theme = _props$theme === void 0 ? {} : _props$theme,\n      _props$target = props.target,\n      target = _props$target === void 0 ? '_self' : _props$target,\n      _props$rel = props.rel,\n      rel = _props$rel === void 0 ? 'noreferrer noopener' : _props$rel,\n      className = props.className,\n      component = props.component;\n  props.dir;\n  props.entityKey;\n  props.getEditorState;\n  props.offsetKey;\n  props.setEditorState;\n  props.contentState;\n  props.blockKey;\n  props.start;\n  props.end;\n\n  var otherProps = _objectWithoutPropertiesLoose(props, [\"decoratedText\", \"theme\", \"target\", \"rel\", \"className\", \"component\", \"dir\", \"entityKey\", \"getEditorState\", \"offsetKey\", \"setEditorState\", \"contentState\", \"blockKey\", \"start\", \"end\"]);\n\n  var combinedClassName = clsx(theme == null ? void 0 : theme.link, className);\n  var links = linkify.match(decoratedText);\n  var href = links && links[0] ? links[0].url : '';\n\n  var linkProps = _extends({}, otherProps, {\n    href: href,\n    target: target,\n    rel: rel,\n    className: combinedClassName\n  });\n\n  return component ? /*#__PURE__*/React.createElement(component, linkProps) :\n  /*#__PURE__*/\n  // eslint-disable-next-line jsx-a11y/anchor-has-content\n  React.createElement(\"a\", linkProps);\n}\n\nvar linkify$1 = linkifyIt();\nlinkify$1.tlds(tlds);\n\nfunction extractLinks(text) {\n  return linkify$1.match(text);\n}\n\nvar linkStrategy = function linkStrategy(contentBlock, callback) {\n  var links = extractLinks(contentBlock.getText());\n\n  if (links) {\n    for (var _iterator = _createForOfIteratorHelperLoose(links), _step; !(_step = _iterator()).done;) {\n      var link = _step.value;\n      callback(link.index, link.lastIndex);\n    }\n  }\n};\n\nvar defaultTheme = {\n  link: \"lxvs42t\"\n};\n\nvar index = function (config) {\n  if (config === void 0) {\n    config = {};\n  } // Styles are overwritten instead of merged as merging causes a lot of confusion.\n  // Why? Because when merging a developer needs to know all of the underlying\n  // styles which needs a deep dive into the code. Merging also makes it prone to\n  // errors when upgrading as basically every styling change would become a major\n  // breaking change. 1px of an increased padding can break a whole layout.\n\n\n  var _config = config,\n      component = _config.component,\n      _config$theme = _config.theme,\n      theme = _config$theme === void 0 ? defaultTheme : _config$theme,\n      _config$target = _config.target,\n      target = _config$target === void 0 ? '_self' : _config$target,\n      _config$rel = _config.rel,\n      rel = _config$rel === void 0 ? 'noreferrer noopener' : _config$rel;\n\n  var DecoratedLink = function DecoratedLink(props) {\n    return /*#__PURE__*/React.createElement(Link, _extends({}, props, {\n      theme: theme,\n      target: target,\n      rel: rel,\n      component: component\n    }));\n  };\n\n  return {\n    decorators: [{\n      strategy: linkStrategy,\n      component: DecoratedLink\n    }]\n  };\n};\n\nexport default index;\nexport { extractLinks };","map":null,"metadata":{},"sourceType":"module"}